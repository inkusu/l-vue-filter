{"version":3,"file":"filter.js","sourceRoot":"","sources":["../src/filter.ts"],"names":[],"mappings":";;AAIA,iCAAiC;AAUpB,QAAA,GAAG,GAAG,CAAC,GAAW,EAAE,KAAK,GAAG,EAAE,EAAE,UAAU,GAAG,KAAK,EAAE,EAAE;IAC/D,IAAI,KAAK,IAAI,GAAG,CAAC,MAAM,EAAE;QACrB,OAAO,GAAG,CAAC;KACd;IAED,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,GAAG,UAAU,CAAC;AAC7C,CAAC,CAAC;AASW,QAAA,yBAAyB,GAAG,CACrC,IAAW,EACX,GAAG,GAAG,EAAE,EACR,UAAU,GAAG,GAAG,EAClB,EAAE;IACA,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;QACtB,OAAO,EAAE,CAAC;KACb;IAED,OAAO,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE;QAC7B,IAAI,GAAG,EAAE;YACL,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;SACvD;QAED,OAAO,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,UAAU,GAAG,CAAC,CAAC;IAC9C,CAAC,EAAE,EAAE,CAAC,CAAC;AACX,CAAC,CAAC;AAQW,QAAA,SAAS,GAAG,CAAC,GAAW,EAAE,MAAM,GAAG,GAAG,EAAE,EAAE;IACnD,IAAI,CAAC,GAAG,EAAE;QAAE,OAAO,EAAE,CAAC;KAAE;IAExB,OAAO,MAAM,GAAG,GAAG,CAAC,QAAQ,EAAE,CAAC,OAAO,CAAC,uBAAuB,EAAE,GAAG,CAAC,CAAC;AACzE,CAAC,CAAC;AAOW,QAAA,UAAU,GAAG,CAAC,GAAW,EAAqB,EAAE;IACzD,IAAI,CAAC,GAAG,EAAE;QAAE,OAAO,EAAE,CAAC;KAAE;IAExB,OAAO,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAC1B,CAAC,CAAC;AAQW,QAAA,UAAU,GAAG,CAAC,GAAoB,EAAE,MAAM,GAAG,YAAY,EAAE,EAAE;IACtE,IAAI,CAAC,GAAG,EAAE;QAAE,OAAO,EAAE,CAAC;KAAE;IAGxB,IAAG,CAAC,KAAK,CAAC,GAAa,CAAC,EAAC;QACrB,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC;KACrB;IAGD,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAEnC,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;QAChB,OAAO,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;KAC9B;IAED,OAAO,EAAE,CAAC;AACd,CAAC,CAAC","sourcesContent":["/**\n * 単体テストを実行できるようにするために、フィルタリング系の関数をここで定義\n */\n\nimport * as moment from \"moment\";\n\n/**\n * 文字列カット関数\n *\n * @param str\n * @param limit\n * @param decoration\n * @returns {*}\n */\nexport const cut = (str: string, limit = 20, decoration = \"・・・\") => {\n    if (limit >= str.length) {\n        return str;\n    }\n\n    return str.substr(0, limit) + decoration;\n};\n\n/**\n * 配列からの文字列結合\n *\n * @param list\n * @param key\n * @param decoration\n */\nexport const combinationFromArrayToStr = (\n    list: any[],\n    key = \"\",\n    decoration = \"/\",\n) => {\n    if (!Array.isArray(list)) {\n        return \"\";\n    }\n\n    return list.reduce((x, y, idx) => {\n        if (key) {\n            return idx === 0 ? y[key] : x + decoration + y[key];\n        }\n\n        return idx === 0 ? y : x + decoration + y;\n    }, \"\");\n};\n\n/**\n * 通過の計算\n * @param val\n * @param prefix\n * @returns {string}\n */\nexport const minorUnit = (val: string, prefix = \"￥\") => {\n    if (!val) { return \"\"; }\n\n    return prefix + val.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, \",\");\n};\n\n/**\n * 指定の文字列を半角スペースで分割し、配列に格納する\n * @param val\n * string[] | string\n */\nexport const spaceSplit = (val: string): string[] | string => {\n    if (!val) { return \"\"; }\n\n    return val.split(\" \");\n};\n\n/**\n * 日付のフォーマット\n * @param val\n * @param format\n * @returns {*}\n */\nexport const dateFormat = (val: string | number, format = \"YYYY/MM/DD\") => {\n    if (!val) { return \"\"; }\n\n    // unixタイムとかの対応\n    if(!isNaN(val as number)){\n        val = Number(val);\n    }\n\n    // 日付不正時のmomentの警告対策のため、一度Dateインスタンス化\n    const date = moment(new Date(val));\n\n    if (date.isValid()) {\n        return date.format(format);\n    }\n\n    return \"\";\n};\n"]}